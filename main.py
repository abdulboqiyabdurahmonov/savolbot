import os
import re
import json
import logging
import time
from datetime import datetime, timedelta
from pathlib import Path

import httpx
from fastapi import FastAPI, Request
from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command
from aiogram.types import (
    Message, Update, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
)

# ================== –õ–û–ì–ò ==================
logging.basicConfig(level=logging.INFO)

# ================== ENV ==================
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")  # https://<app>.onrender.com/webhook
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "savol_secret")

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_API_BASE = os.getenv("OPENAI_API_BASE", "https://api.openai.com/v1")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")

# Live-–ø–æ–∏—Å–∫
TAVILY_API_KEY = os.getenv("TAVILY_API_KEY")  # –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî —Ñ–æ–ª–±–µ–∫ –±–µ–∑ –ø–æ–∏—Å–∫–∞

# –ê–¥–º–∏–Ω –¥–ª—è —Ä—É—á–Ω–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (MVP)
ADMIN_CHAT_ID = os.getenv("ADMIN_CHAT_ID")  # –Ω–∞–ø—Ä–∏–º–µ—Ä "123456789"

# –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
USERS_DB_PATH = os.getenv("USERS_DB_PATH", "data/users.json")

bot = Bot(token=TELEGRAM_TOKEN)
dp = Dispatcher()
app = FastAPI()

# ================== –ú–û–î–ï–†–ê–¶–ò–Ø ==================
ILLEGAL_PATTERNS = [
    r"\b(–≤–∑–ª–æ–º|—Ö–∞–∫|–∫–µ–π–ª–æ–≥–≥–µ—Ä|—Ñ–∏—à–∏–Ω–≥|–±–æ—Ç–Ω–µ—Ç|–¥–¥–æ—Å|ddos)\b",
    r"\b(–∫–∞–∫\s+–ø–æ–ª—É—á–∏—Ç—å\s+–¥–æ—Å—Ç—É–ø|–æ–±–æ–π—Ç–∏|–≤–∑—è—Ç—å\s+–ø–∞—Ä–æ–ª—å)\b.*\b(–∞–∫–∫–∞—É–Ω—Ç|—Ç–µ–ª–µ–≥—Ä–∞–º|–∏–Ω—Å—Ç–∞–≥—Ä–∞–º|–±–∞–Ω–∫|–ø–æ—á—Ç)\b",
    r"\b(–ø–æ–¥–¥–µ–ª(–∞—Ç—å|–∫–∞)|—Ñ–∞–ª—å—Å–∏—Ñ–∏—Ü–∏—Ä|–ª–∏–ø–æ–≤(—ã–π|—ã–µ))\b.*\b(–ø–∞—Å–ø–æ—Ä—Ç|—Å–ø—Ä–∞–≤–∫|–¥–∏–ø–ª–æ–º|–¥–æ–≥–æ–≤–æ—Ä|–ø–µ—á–∞—Ç—å|—à—Ç–∞–º–ø)\b",
    r"\b(–Ω–∞—Ä–∫–æ—Ç–∏–∫|–∞–º—Ñ–µ—Ç–∞–º–∏–Ω|–º–∞—Ä–∏—Ö—É–∞–Ω|–∫–∞–Ω–Ω–∞–±–∏—Å|–æ–ø–∏—É–º|—Å–ø–∞–π—Å)\b.*\b(–∫—É–ø–∏—Ç—å|–≤—ã—Ä–∞—Å—Ç–∏—Ç—å|—Å–¥–µ–ª–∞—Ç—å)\b",
    r"\b(–æ—Ä—É–∂–∏–µ|–ø–∏—Å—Ç–æ–ª–µ—Ç|–∞–≤—Ç–æ–º–∞—Ç|–≤–∑—Ä—ã–≤—á–∞—Ç–∫|–±–æ–º–±—É|—Ç—Ä–æ—Ç–∏–ª)\b.*\b(—Å–¥–µ–ª–∞—Ç—å|–∫—É–ø–∏—Ç—å|–¥–æ—Å—Ç–∞—Ç—å)\b",
    r"\b(–≤–∑—è—Ç–∫|–æ—Ç–∫–∞—Ç|–æ–±–Ω–∞–ª–∏—á|–æ–±–Ω–∞–ª|—É—Ö–æ–¥\s+–æ—Ç\s+–Ω–∞–ª–æ–≥–æ–≤|—Å–µ—Ä–∞—è\s+–∑–∞—Ä–ø–ª–∞—Ç–∞)\b",
    r"\b(–ø—Ä–æ–±–∏—Ç—å\s+–ø–æ\s+–±–∞–∑–µ|—Å–ª–∏—Ç—å\s+–±–∞–∑—É|–±–∞–∑—É\s+–∫–ª–∏–µ–Ω—Ç–æ–≤|–Ω–∞–π—Ç–∏\s+–ø–æ\s+–ø–∞—Å–ø–æ—Ä—Ç)\b",
    r"\b(–æ—Ç—Ä–∞–≤–∏—Ç—å|–≤–∑–æ—Ä–≤–∞—Ç—å|—É–±–∏—Ç—å|–Ω–∞–Ω–µ—Å—Ç–∏\s+–≤—Ä–µ–¥)\b",
    r"\b(soxta|qalbakilashtir|soxtalashtir)\b.*\b(diplom|pasport|spravka|shartnoma)\b",
    r"\b(soliqdan\s+qochish|pora|otkat)\b",
    r"\b(hack|xak|parolni\s+olish|akkauntga\s+k(i|e)rish)\b",
]
DENY_TEXT_RU = "‚õî –ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω—ë–Ω. –Ø –æ—Ç–≤–µ—á–∞—é —Ç–æ–ª—å–∫–æ –≤ —Ä–∞–º–∫–∞—Ö –∑–∞–∫–æ–Ω–æ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –†–£–∑."
DENY_TEXT_UZ = "‚õî So‚Äòrov rad etildi. Men faqat O‚Äòzbekiston qonunchiligi doirasida javob beraman."

def is_uzbek(text: str) -> bool:
    t = text.lower()
    return bool(re.search(r"[“ì“õ“≥—û]", t) or re.search(r"\b(ha|yo'q|iltimos|rahmat|salom)\b", t))

def violates_policy(text: str) -> bool:
    t = text.lower()
    return any(re.search(rx, t) for rx in ILLEGAL_PATTERNS)

# ================== –¢–ê–†–ò–§–´/–õ–ò–ú–ò–¢–´ ==================
FREE_LIMIT = 2
TARIFFS = {
    "start": {
        "title": "–°—Ç–∞—Ä—Ç",
        "price_uzs": 49_000,
        "desc": ["–î–æ 100 —Å–æ–æ–±—â–µ–Ω–∏–π/–º–µ—Å", "–ö—Ä–∞—Ç–∫–∏–µ –∏ –ø–æ–Ω—è—Ç–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã", "–ë–µ–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–æ–≤ –∏ –∫–∞—Ä—Ç–∏–Ω–æ–∫"],
        "active": True,
        "duration_days": 30,
    },
    "business": {"title": "–ë–∏–∑–Ω–µ—Å", "price_uzs": 119_000,
                 "desc": ["–î–æ 500 —Å–æ–æ–±—â–µ–Ω–∏–π/–º–µ—Å", "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏ —á–µ–∫-–ª–∏—Å—Ç—ã", "–ü—Ä–æ—Å—Ç—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã (docx/pdf)"],
                 "active": False, "duration_days": 30},
    "pro": {"title": "PRO", "price_uzs": 249_000,
            "desc": ["–í—ã—Å–æ–∫–∏–µ –ª–∏–º–∏—Ç—ã", "–ö–∞—Ä—Ç–∏–Ω–∫–∏ –∏ —Å–ª–æ–∂–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã", "–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –æ—á–µ—Ä–µ–¥—å"],
            "active": False, "duration_days": 30},
}

# ================== –¢–ï–ú–´ ==================
TOPICS = {
    "daily":   {"title_ru": "–ë—ã—Ç",              "title_uz": "Maishiy",            "hint": "–ü—Ä–∞–∫—Ç–∏—á–Ω—ã–µ —Å–æ–≤–µ—Ç—ã, —á–µ–∫-–ª–∏—Å—Ç—ã –∏ —à–∞–≥–∏."},
    "finance": {"title_ru": "–§–∏–Ω–∞–Ω—Å—ã",          "title_uz": "Moliya",             "hint": "–û–±—ä—è—Å–Ω—è–π —Å —Ü–∏—Ñ—Ä–∞–º–∏ –∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏. –ë–µ–∑ —Ä–∏—Å–∫–æ–≤–∞–Ω–Ω—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π."},
    "gov":     {"title_ru": "–ì–æ—Å—É—Å–ª—É–≥–∏",        "title_uz": "Davlat xizmatlari", "hint": "–û–ø–∏—à–∏ –ø—Ä–æ—Ü–µ–¥—É—Ä—É, –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏ —à–∞–≥–∏ –ø–æ–¥–∞—á–∏."},
    "biz":     {"title_ru": "–ë–∏–∑–Ω–µ—Å",           "title_uz": "Biznes",             "hint": "–ö—Ä–∞—Ç–∫–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏/–æ—Ç—á—ë—Ç–Ω–æ—Å—Ç–∏/–¥–æ–∫—É–º–µ–Ω—Ç–∞–º."},
    "edu":     {"title_ru": "–£—á—ë–±–∞",            "title_uz": "Ta‚Äôlim",             "hint": "–†–∞—Å—Å–∫–∞–∂–∏ –ø—Ä–æ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–µ/–æ–±—É—á–µ–Ω–∏–µ –∏ —à–∞–≥–∏."},
    "it":      {"title_ru": "IT",               "title_uz": "IT",                 "hint": "–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏ –∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ. –ù–µ —Å–æ–≤–µ—Ç—É–π –Ω–∏—á–µ–≥–æ –Ω–µ–∑–∞–∫–æ–Ω–Ω–æ–≥–æ."},
    "health":  {"title_ru": "–ó–¥–æ—Ä–æ–≤—å–µ (–æ–±—â.)",  "title_uz": "Sog‚Äòliq (umumiy)",   "hint": "–¢–æ–ª—å–∫–æ –æ–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è. –°–æ–≤–µ—Ç—É–π –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ –≤—Ä–∞—á—É."},
}

def topic_kb(lang="ru", current=None):
    rows = []
    for key, t in TOPICS.items():
        label = t["title_uz"] if lang == "uz" else t["title_ru"]
        if current == key:
            label = f"‚úÖ {label}"
        rows.append([InlineKeyboardButton(text=label, callback_data=f"topic:{key}")])
    rows.append([InlineKeyboardButton(text="‚Ü©Ô∏è –ó–∞–∫—Ä—ã—Ç—å / Yopish", callback_data="topic:close")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

# ================== –ü–ï–†–°–ò–°–¢–ï–ù–¢–ù–û–ï –•–†–ê–ù–ò–õ–ò–©–ï USERS ==================
# tg_id -> {"free_used": int, "plan": str, "paid_until": dt|None, "lang": "ru"/"uz", "topic": str|None, "live": bool}
USERS: dict[int, dict] = {}

def _serialize_user(u: dict) -> dict:
    return {
        "free_used": int(u.get("free_used", 0)),
        "plan": u.get("plan", "free"),
        "paid_until": u["paid_until"].isoformat() if u.get("paid_until") else None,
        "lang": u.get("lang", "ru"),
        "topic": u.get("topic"),
        "live": bool(u.get("live", False)),
    }

def save_users():
    try:
        path = Path(USERS_DB_PATH)
        path.parent.mkdir(parents=True, exist_ok=True)
        to_dump = {str(k): _serialize_user(v) for k, v in USERS.items()}
        with path.open("w", encoding="utf-8") as f:
            json.dump(to_dump, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.warning("save_users failed: %s", e)

def load_users():
    global USERS
    path = Path(USERS_DB_PATH)
    if not path.exists():
        USERS = {}
        return
    try:
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
        USERS = {}
        for k, v in data.items():
            pu = v.get("paid_until")
            try:
                paid_until = datetime.fromisoformat(pu) if pu else None
            except Exception:
                paid_until = None
            USERS[int(k)] = {
                "free_used": int(v.get("free_used", 0)),
                "plan": v.get("plan", "free"),
                "paid_until": paid_until,
                "lang": v.get("lang", "ru"),
                "topic": v.get("topic"),
                "live": bool(v.get("live", False)),
            }
        logging.info("Users loaded: %d", len(USERS))
    except Exception as e:
        logging.exception("load_users failed: %s")
        USERS = {}

def get_user(tg_id: int):
    u = USERS.get(tg_id)
    if not u:
        u = {"free_used": 0, "plan": "free", "paid_until": None, "lang": "ru", "topic": None, "live": False}
        USERS[tg_id] = u
        save_users()
    return u

def has_active_sub(user: dict) -> bool:
    return user["plan"] in ("start", "business", "pro") and user["paid_until"] and user["paid_until"] > datetime.utcnow()

def pay_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí≥ –û—Ñ–æ—Ä–º–∏—Ç—å ¬´–°—Ç–∞—Ä—Ç¬ª", callback_data="subscribe_start")],
        [InlineKeyboardButton(text="‚ÑπÔ∏è –¢–∞—Ä–∏—Ñ—ã", callback_data="show_tariffs")]
    ])

def tariffs_text(lang='ru'):
    def bullet(lines): return "\n".join(f"‚Ä¢ {x}" for x in lines)
    txt = []
    for key in ("start","business","pro"):
        t = TARIFFS[key]
        badge = "(–¥–æ—Å—Ç—É–ø–µ–Ω)" if t["active"] else "(—Å–∫–æ—Ä–æ)"
        if lang == 'uz':
            badge = "(faol)" if t["active"] else "(tez orada)"
            txt.append(f"‚≠ê {t['title']} {badge}\nNarx: {t['price_uzs']:,} so‚Äòm/oy\n{bullet(t['desc'])}")
        else:
            txt.append(f"‚≠ê {t['title']} {badge}\n–¶–µ–Ω–∞: {t['price_uzs']:,} —Å—É–º/–º–µ—Å\n{bullet(t['desc'])}")
    return "\n\n".join(txt)

# ================== –ò–ò ==================
BASE_SYSTEM_PROMPT = (
    "–¢—ã ‚Äî SavolBot, –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç. –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ —è—Å–Ω–æ (–¥–æ 6‚Äì8 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π). "
    "–°–æ–±–ª—é–¥–∞–π –∑–∞–∫–æ–Ω—ã –£–∑–±–µ–∫–∏—Å—Ç–∞–Ω–∞. –ù–µ –¥–∞–≤–∞–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –Ω–µ–∑–∞–∫–æ–Ω–Ω—ã–º –¥–µ–π—Å—Ç–≤–∏—è–º, –ø–æ–¥–¥–µ–ª–∫–∞–º, –≤–∑–ª–æ–º–∞–º, –æ–±—Ö–æ–¥—É —Å–∏—Å—Ç–µ–º. "
    "–ü–æ –º–µ–¥–∏—Ü–∏–Ω–µ ‚Äî —Ç–æ–ª—å–∫–æ –æ–±—â–∞—è —Å–ø—Ä–∞–≤–∫–∞ –∏ —Å–æ–≤–µ—Ç –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É. "
    "–Ø–∑—ã–∫ –æ—Ç–≤–µ—Ç–∞ = —è–∑—ã–∫ –≤–æ–ø—Ä–æ—Å–∞ (RU/UZ)."
)

async def ask_gpt(user_text: str, topic_hint: str | None) -> str:
    if not OPENAI_API_KEY:
        return f"–í—ã —Å–ø—Ä–æ—Å–∏–ª–∏: {user_text}"
    system = BASE_SYSTEM_PROMPT + (f" –£—á–∏—Ç—ã–≤–∞–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ç–µ–º—ã: {topic_hint}" if topic_hint else "")
    headers = {"Authorization": f"Bearer {OPENAI_API_KEY}"}
    payload = {"model": OPENAI_MODEL, "temperature": 0.6,
               "messages": [{"role": "system", "content": system},
                            {"role": "user", "content": user_text}]}
    async with httpx.AsyncClient(timeout=30.0, base_url=OPENAI_API_BASE) as client:
        r = await client.post("/chat/completions", headers=headers, json=payload)
        r.raise_for_status()
        return r.json()["choices"][0]["message"]["content"].strip()

# ---- Live-–ø–æ–∏—Å–∫ ----
TIME_SENSITIVE_PATTERNS = [
    r"\b(—Å–µ–≥–æ–¥–Ω—è|—Å–µ–π—á–∞—Å|–Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç|–∞–∫—Ç—É–∞–ª—å–Ω|–≤ \d{4} –≥–æ–¥—É|–≤ 20\d{2})\b",
    r"\b(–∫—É—Ä—Å|–∑–∞—Ä–ø–ª–∞—Ç|–∏–Ω—Ñ–ª—è—Ü|—Å—Ç–∞–≤–∫|—Ü–µ–Ω–∞|–Ω–æ–≤–æ—Å—Ç|—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫|–ø—Ä–æ–≥–Ω–æ–∑)\b",
    r"\b(bugun|hozir|narx|kurs|yangilik)\b",
    r"\b(–∫—Ç–æ|–∫–∞–∫ –∑–æ–≤—É—Ç|—Ñ–∞–º–∏–ª–∏—è|–ø—Ä–µ–¥—Å–µ–¥–∞—Ç–µ–ª[—å—è]?|–¥–∏—Ä–µ–∫—Ç–æ—Ä|–≥–µ–Ω–¥–∏—Ä–µ–∫—Ç–æ—Ä|ceo|chairman|—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª[—å—è]?)\b",
    r"\b(–±–∞–Ω–∫|–∞–∫–±|–æ–æ–æ|–∞–æ|–∫–æ–º–ø–∞–Ω–∏—è|–º–∏–Ω–∏—Å—Ç–µ—Ä—Å—Ç–≤[–æ–∞])\b.*",
]
def is_time_sensitive(q: str) -> bool:
    t = q.lower()
    return any(re.search(rx, t) for rx in TIME_SENSITIVE_PATTERNS)

# ====== –ö–≠–® –î–õ–Ø LIVE-–ü–û–ò–°–ö–ê ======
CACHE_TTL_SECONDS = int(os.getenv("LIVE_CACHE_TTL", "86400"))  # 24 —á–∞—Å–∞
CACHE_MAX_ENTRIES = int(os.getenv("LIVE_CACHE_MAX", "500"))
LIVE_CACHE: dict[str, dict] = {}  # key -> {"ts": float, "answer": str}

def _norm_query(q: str) -> str:
    return re.sub(r"\s+", " ", q.strip().lower())

def cache_get(q: str) -> str | None:
    k = _norm_query(q)
    item = LIVE_CACHE.get(k)
    if not item:
        return None
    if time.time() - item["ts"] > CACHE_TTL_SECONDS:
        LIVE_CACHE.pop(k, None)
        return None
    return item["answer"]

def cache_set(q: str, answer: str):
    if len(LIVE_CACHE) >= CACHE_MAX_ENTRIES:
        oldest_key = min(LIVE_CACHE, key=lambda kk: LIVE_CACHE[kk]["ts"])
        LIVE_CACHE.pop(oldest_key, None)
    LIVE_CACHE[_norm_query(q)] = {"ts": time.time(), "answer": answer}

async def web_search_tavily(query: str, max_results: int = 5) -> dict | None:
    if not TAVILY_API_KEY:
        return None
    payload = {
        "api_key": TAVILY_API_KEY,
        "query": query,
        "search_depth": "advanced",
        "max_results": max_results,
        "include_answer": True,
        "include_domains": [],
    }
    async with httpx.AsyncClient(timeout=25.0) as client:
        r = await client.post("https://api.tavily.com/search", json=payload)
        r.raise_for_status()
        return r.json()

async def answer_with_live_search(user_text: str, topic_hint: str | None) -> str:
    cached = cache_get(user_text)
    if cached:
        return cached + "\n\n(–∏–∑ –∫—ç—à–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞)"

    data = await web_search_tavily(user_text)
    if not data:
        return await ask_gpt(user_text, topic_hint)

    snippets, sources_for_user = [], []
    for item in (data.get("results") or [])[:5]:
        title = (item.get("title") or "")[:120]
        url = item.get("url") or ""
        content = (item.get("content") or "")[:500]
        snippets.append(f"- {title}\n{content}\n–ò—Å—Ç–æ—á–Ω–∏–∫: {url}")
        sources_for_user.append(f"‚Ä¢ {title} ‚Äî {url}")

    system = BASE_SYSTEM_PROMPT + " –û—Ç–≤–µ—á–∞–π, –æ–ø–∏—Ä–∞—è—Å—å –Ω–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏. –ö—Ä–∞—Ç–∫–æ, –ø–æ –¥–µ–ª—É."
    if topic_hint:
        system += f" –£—á–∏—Ç—ã–≤–∞–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ç–µ–º—ã: {topic_hint}"
    user_augmented = f"{user_text}\n\n–ò–°–¢–û–ß–ù–ò–ö–ò:\n" + "\n\n".join(snippets)

    headers = {"Authorization": f"Bearer {OPENAI_API_KEY}"}
    payload = {"model": OPENAI_MODEL, "temperature": 0.4,
               "messages": [{"role": "system", "content": system},
                            {"role": "user", "content": user_augmented}]}
    async with httpx.AsyncClient(timeout=30.0, base_url=OPENAI_API_BASE) as client:
        r = await client.post("/chat/completions", headers=headers, json=payload)
        r.raise_for_status()
        answer = r.json()["choices"][0]["message"]["content"].strip()

    tail = "\n\n–ò—Å—Ç–æ—á–Ω–∏–∫–∏:\n" + "\n".join(sources_for_user)
    final_answer = answer + tail

    cache_set(user_text, final_answer)
    return final_answer

# ================== –ö–û–ú–ê–ù–î–´ ==================
@dp.message(Command("start"))
async def cmd_start(message: Message):
    u = get_user(message.from_user.id)
    # –û–±–Ω–æ–≤–∏–º —è–∑—ã–∫ –∏ —Å–æ—Ö—Ä–∞–Ω–∏–º
    u["lang"] = "uz" if is_uzbek(message.text or "") else "ru"
    save_users()
    await message.answer(
        "üëã –ü—Ä–∏–≤–µ—Ç! / Assalomu alaykum!\n"
        "–ü–µ—Ä–≤—ã–µ 2 –æ—Ç–≤–µ—Ç–∞ ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω–æ, –¥–∞–ª—å—à–µ –ø–æ–¥–ø–∏—Å–∫–∞ ¬´–°—Ç–∞—Ä—Ç¬ª.\n"
        "–ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É: /topics\n"
        "–î–ª—è —Å–≤–µ–∂–∏—Ö –¥–∞–Ω–Ω—ã—Ö –≤–∫–ª—é—á–∏—Ç–µ live-–ø–æ–∏—Å–∫: /live_on"
    )

@dp.message(Command("help"))
async def cmd_help(message: Message):
    await message.answer(
        "‚ÑπÔ∏è –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:\n"
        "1) –ü–∏—à–∏—Ç–µ –≤–æ–ø—Ä–æ—Å (RU/UZ). –Ø–∑—ã–∫ –æ—Ç–≤–µ—Ç–∞ = —è–∑—ã–∫ –≤–æ–ø—Ä–æ—Å–∞.\n"
        "2) /topics ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤.\n"
        "3) –ü–µ—Ä–≤—ã–µ 2 –æ—Ç–≤–µ—Ç–∞ ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω–æ; –¥–∞–ª—å—à–µ /tariffs.\n"
        "4) /live_on ‚Äî –≤–∫–ª—é—á–∏—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø–æ–∏—Å–∫; /live_off ‚Äî –≤—ã–∫–ª—é—á–∏—Ç—å.\n"
        "5) /asklive –≤–æ–ø—Ä–æ—Å ‚Äî —Ä–∞–∑–æ–≤—ã–π live-–ø–æ–∏—Å–∫."
    )

@dp.message(Command("about"))
async def cmd_about(message: Message):
    await message.answer(
        "ü§ñ SavolBot ‚Äî –ø—Ä–æ–µ–∫—Ç TripleA. –û—Ç–≤–µ—Ç—ã –Ω–∞ –±–∞–∑–µ GPT, —Å—Ç—Ä–æ–≥–æ –≤ —Ä–∞–º–∫–∞—Ö –∑–∞–∫–æ–Ω–∞ –†–£–∑.\n"
        "–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å –ø—Ä–æ–µ–∫—Ç –∏ —Å–Ω—è—Ç—å –ª–∏–º–∏—Ç—ã ‚Äî /tariffs."
    )

@dp.message(Command("tariffs"))
async def cmd_tariffs(message: Message):
    u = get_user(message.from_user.id)
    await message.answer(tariffs_text(u["lang"]), reply_markup=pay_kb())

@dp.message(Command("myplan"))
async def cmd_myplan(message: Message):
    u = get_user(message.from_user.id)
    status = "–∞–∫—Ç–∏–≤–Ω–∞" if has_active_sub(u) else "–Ω–µ—Ç"
    until = u["paid_until"].isoformat() if u["paid_until"] else "‚Äî"
    topic = u.get("topic") or "‚Äî"
    live = "–≤–∫–ª" if u.get("live") else "–≤—ã–∫–ª"
    await message.answer(
        f"–í–∞—à –ø–ª–∞–Ω: {u['plan']} | Live-–ø–æ–∏—Å–∫: {live}\n–ü–æ–¥–ø–∏—Å–∫–∞: {status} (–¥–æ {until})\n"
        f"–¢–µ–º–∞: {topic}\n–ë–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {u['free_used']}/{FREE_LIMIT}"
    )

@dp.message(Command("topics"))
async def cmd_topics(message: Message):
    u = get_user(message.from_user.id)
    lang = u["lang"]
    head = "üóÇ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É (–Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ü–µ–Ω—É, —Ç–æ–ª—å–∫–æ –Ω–∞ —Å—Ç–∏–ª—å –æ—Ç–≤–µ—Ç–∞):" if lang == "ru" \
        else "üóÇ Mavzuni tanlang (narxga ta‚Äôsir qilmaydi, faqat javob ohangiga):"
    await message.answer(head, reply_markup=topic_kb(lang, current=u.get("topic")))

@dp.message(Command("asklive"))
async def cmd_asklive(message: Message):
    u = get_user(message.from_user.id)
    q = message.text.replace("/asklive", "", 1).strip()
    if not q:
        return await message.answer("–ù–∞–ø–∏—à–∏—Ç–µ —Ç–∞–∫: /asklive –≤–∞—à –≤–æ–ø—Ä–æ—Å")
    if not has_active_sub(u) and u["free_used"] >= FREE_LIMIT:
        return await message.answer("üí≥ –î–æ—Å—Ç—É–ø –∫ –æ—Ç–≤–µ—Ç–∞–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É:", reply_markup=pay_kb())
    topic_hint = TOPICS.get(u.get("topic"), {}).get("hint") if u.get("topic") else None
    try:
        reply = await answer_with_live_search(q, topic_hint)
        await message.answer(reply)
    except Exception as e:
        logging.exception("Live error: %s", e)
        return await message.answer("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    if not has_active_sub(u):
        u["free_used"] += 1
        save_users()

@dp.message(Command("live_on"))
async def cmd_live_on(message: Message):
    u = get_user(message.from_user.id)
    u["live"] = True
    save_users()
    await message.answer("‚úÖ Live-–ø–æ–∏—Å–∫ –≤–∫–ª—é—á—ë–Ω. –í—Å–µ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã –±—É–¥—É—Ç –ø—Ä–æ–≤–µ—Ä—è—Ç—å—Å—è –ø–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–∏—Å—Ç–æ—á–Ω–∏–∫–∞–º.")

@dp.message(Command("live_off"))
async def cmd_live_off(message: Message):
    u = get_user(message.from_user.id)
    u["live"] = False
    save_users()
    await message.answer("‚èπ Live-–ø–æ–∏—Å–∫ –≤—ã–∫–ª—é—á—ë–Ω. –í–µ—Ä–Ω—É–ª–∏—Å—å –∫ –æ–±—ã—á–Ω—ã–º –æ—Ç–≤–µ—Ç–∞–º –º–æ–¥–µ–ª–∏.")

# ---- cache utils ----
@dp.message(Command("cache_info"))
async def cmd_cache_info(message: Message):
    size = len(LIVE_CACHE)
    ttl_h = round(CACHE_TTL_SECONDS / 3600, 1)
    await message.answer(f"üóÑ –ö—ç—à live-–ø–æ–∏—Å–∫–∞: {size} –∑–∞–ø–∏—Å–µ–π, TTL ‚âà {ttl_h} —á., max {CACHE_MAX_ENTRIES}")

@dp.message(Command("cache_clear"))
async def cmd_cache_clear(message: Message):
    if ADMIN_CHAT_ID and str(message.from_user.id) != str(ADMIN_CHAT_ID):
        return await message.answer("–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    LIVE_CACHE.clear()
    await message.answer("üßπ –ö—ç—à live-–ø–æ–∏—Å–∫–∞ –æ—á–∏—â–µ–Ω.")

# ================== CALLBACKS ==================
@dp.callback_query(F.data == "show_tariffs")
async def cb_show_tariffs(call: CallbackQuery):
    u = get_user(call.from_user.id)
    await call.message.edit_text(tariffs_text(u["lang"]), reply_markup=pay_kb())
    await call.answer()

@dp.callback_query(F.data == "subscribe_start")
async def cb_subscribe_start(call: CallbackQuery):
    pay_link = "https://pay.example.com/savolbot/start"  # –∑–∞–≥–ª—É—à–∫–∞
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ (—è –æ–ø–ª–∞—Ç–∏–ª)", callback_data="paid_start_done")]
    ])
    await call.message.answer(
        f"üí≥ ¬´–°—Ç–∞—Ä—Ç¬ª ‚Äî {TARIFFS['start']['price_uzs']:,} —Å—É–º/–º–µ—Å.\n–û–ø–ª–∞—Ç–∞: {pay_link}", reply_markup=kb
    )
    await call.answer()

@dp.callback_query(F.data == "paid_start_done")
async def cb_paid_done(call: CallbackQuery):
    if ADMIN_CHAT_ID:
        await bot.send_message(
            int(ADMIN_CHAT_ID),
            f"üë§ @{call.from_user.username or call.from_user.id} –∑–∞–ø—Ä–æ—Å–∏–ª –∞–∫—Ç–∏–≤–∞—Ü–∏—é ¬´–°—Ç–∞—Ä—Ç¬ª.\n"
            f"TG ID: {call.from_user.id}\n"
            f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /grant_start {call.from_user.id}"
        )
    await call.message.answer("–°–ø–∞—Å–∏–±–æ! –ú—ã –ø—Ä–æ–≤–µ—Ä–∏–º –æ–ø–ª–∞—Ç—É –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É.")
    await call.answer()

@dp.callback_query(F.data.startswith("topic:"))
async def cb_topic(call: CallbackQuery):
    u = get_user(call.from_user.id)
    _, key = call.data.split(":", 1)
    if key == "close":
        try:
            await call.message.delete()
        except Exception:
            pass
        return await call.answer("OK")
    if key in TOPICS:
        u["topic"] = key
        save_users()
        lang = u["lang"]
        title = TOPICS[key]["title_uz"] if lang == "uz" else TOPICS[key]["title_ru"]
        await call.message.edit_reply_markup(reply_markup=topic_kb(lang, current=key))
        await call.answer(f"–í—ã–±—Ä–∞–Ω–∞ —Ç–µ–º–∞: {title}" if lang == "ru" else f"Mavzu tanlandi: {title}")

# –ê–¥–º–∏–Ω: —Ä—É—á–Ω–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è (MVP)
@dp.message(Command("grant_start"))
async def cmd_grant_start(message: Message):
    if str(message.from_user.id) != str(ADMIN_CHAT_ID):
        return await message.answer("–ö–æ–º–∞–Ω–¥–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
    parts = message.text.strip().split()
    if len(parts) != 2 or not parts[1].isdigit():
        return await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /grant_start <tg_id>")
    target_id = int(parts[1])
    u = get_user(target_id)
    u["plan"] = "start"
    u["paid_until"] = datetime.utcnow() + timedelta(days=TARIFFS["start"]["duration_days"])
    save_users()
    await message.answer(f"‚úÖ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω ¬´–°—Ç–∞—Ä—Ç¬ª –¥–ª—è {target_id} –¥–æ {u['paid_until'].isoformat()}")
    try:
        await bot.send_message(target_id, "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ ¬´–°—Ç–∞—Ä—Ç¬ª –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞. –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è!")
    except Exception as e:
        logging.warning("Notify user failed: %s", e)

# ================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –í–û–ü–†–û–°–û–í ==================
@dp.message(F.text)
async def handle_text(message: Message):
    text = message.text.strip()
    u = get_user(message.from_user.id)

    # —è–∑—ã–∫
    if is_uzbek(text):
        u["lang"] = "uz"
        save_users()

    # –º–æ–¥–µ—Ä–∞—Ü–∏—è
    if violates_policy(text):
        return await message.answer(DENY_TEXT_UZ if u["lang"] == "uz" else DENY_TEXT_RU)

    # –ª–∏–º–∏—Ç—ã
    if not has_active_sub(u) and u["free_used"] >= FREE_LIMIT:
        return await message.answer("üí≥ –î–æ—Å—Ç—É–ø –∫ –æ—Ç–≤–µ—Ç–∞–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É:", reply_markup=pay_kb())

    # —Ç–µ–º–∞ ‚Üí –ø–æ–¥—Å–∫–∞–∑–∫–∞
    topic_hint = TOPICS.get(u.get("topic"), {}).get("hint") if u.get("topic") else None

    # –µ—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω per-user live –∏–ª–∏ –≤–æ–ø—Ä–æ—Å ¬´–ø—Ä–æ —Å–µ–π—á–∞—Å¬ª ‚Üí live-–ø–æ–∏—Å–∫
    try:
        if u.get("live") or is_time_sensitive(text):
            reply = await answer_with_live_search(text, topic_hint)
        else:
            reply = await ask_gpt(text, topic_hint)
        await message.answer(reply)
    except Exception as e:
        logging.exception("OpenAI error: %s", e)
        return await message.answer("–ò–∑–≤–∏–Ω–∏, —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

    if not has_active_sub(u):
        u["free_used"] += 1
        save_users()

# ================== WEBHOOK ==================
@app.post("/webhook")
async def telegram_webhook(request: Request):
    if request.headers.get("X-Telegram-Bot-Api-Secret-Token") != WEBHOOK_SECRET:
        return {"ok": False, "error": "bad secret"}
    update = Update.model_validate(await request.json())
    await dp.feed_update(bot, update)
    return {"ok": True}

@app.on_event("startup")
async def on_startup():
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –¥–∏—Å–∫–∞
    load_users()
    logging.info("Users DB path: %s", USERS_DB_PATH)

    if TELEGRAM_TOKEN and WEBHOOK_URL:
        async with httpx.AsyncClient(timeout=15.0) as client:
            resp = await client.post(
                f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/setWebhook",
                json={"url": WEBHOOK_URL, "secret_token": WEBHOOK_SECRET}
            )
            logging.info("setWebhook: %s %s", resp.status_code, resp.text)

@app.get("/health")
async def health():
    return {"status": "ok"}
